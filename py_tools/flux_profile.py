#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Thu Mar  1 11:20:18 2018

@author: dartoon

Propose:
    derive the SB/tot_flux profile when give a fit.
"""

import numpy as np
from regions import PixCoord, CirclePixelRegion 
import astropy.io.fits as pyfits
import matplotlib.pyplot as plt
from matplotlib.ticker import AutoMinorLocator

def pix_region(center=([49,49]), radius=5):
    '''
    Creat a region file, with pixel units
    
    Parameter
    --------
        center: The center of the region, with ([reg_x, reg_y]);
        radius: The radius of the region.
        
    Return
    --------
        A region which is ds9-like.
    '''
    center= PixCoord(x=center[0],y=center[1])
    region = CirclePixelRegion(center, radius)
    return region

def flux_in_region(image,region,mode='exact'):
    '''
    Calculate the total flux inside a given region.
    
    Parameter
    --------
        image: 2-D array image;
        region: The region generated by pix_region;
        mode: mode type of the mask, 'exact', 'center', default is 'exact'.
        
    Returns
    --------
        Total flux
    '''
    mask = region.to_mask(mode=mode)
    data = mask.cutout(image)
    tot_flux= np.sum(mask.data * data)
    return tot_flux

def flux_profile(image, center, radius=35, grids=20, ifplot=True, fits_plot=True):
    '''
    Derive the flux profile of one image start at the center.
    
    Parameters
    --------
        image: A 2-D array image;
        center: The center point of the profile;
        radius: The radius of the profile favourable with default equals to 35;
        grids: The number of points to sample the flux with default equals to 20;
        ifplot: if plot the profile
        fits_plot: if plot the fits file with the regions.
    Returns
    --------
        1. A 1-D array of the tot_flux value of each 'grids' in the profile sampled radius. 
        2. The grids of each pixel radius.
        3. The region file for each radius.
    '''
    r_grids=(np.linspace(0,1,grids+1)*radius)[1:]
    r_flux = np.empty(grids)
    regions = []
    for i in range(len(r_grids)):
        region = pix_region(center, r_grids[i])
        r_flux[i] =flux_in_region(image, region)
        regions.append(region)
    if fits_plot == True:
        ax=plt.subplot(1,1,1)
        cax=ax.imshow((image),origin='lower')
        #ax.add_patch(mask.bbox.as_patch(facecolor='none', edgecolor='white'))
        for i in range(grids):
            ax.add_patch(regions[i].as_patch(facecolor='none', edgecolor='orange'))
        plt.colorbar(cax)
        plt.show()
    if ifplot == True:
        minorLocator = AutoMinorLocator()
        fig, ax = plt.subplots()
        plt.plot(r_grids, r_flux, 'x-')
        ax.xaxis.set_minor_locator(minorLocator)
        plt.tick_params(which='both', width=2)
        plt.tick_params(which='major', length=7)
        plt.tick_params(which='minor', length=4, color='r')
        plt.grid()
        ax.set_ylabel("Total Flux")
        ax.set_xlabel("Pixels")
        plt.grid(which="minor")
        plt.show()
    return r_flux, r_grids, regions

def SB_profile(image, center, radius=35, grids=20,
               ifplot=False, fits_plot=False, if_mask=False,
               mask_NO=1, mask_reg=['default.reg']):
    '''
    Derive the SB profile of one image start at the center.
    
    Parameters
    --------
        image: A 2-D array image;
        center: The center point of the profile;
        radius: The radius of the profile favourable with default equals to 35;
        grids: The number of points to sample the flux with default equals to 20;
        ifplot: if plot the profile
        fits_plot: if plot the fits file with the regions.
    Returns
    --------
        A 1-D array of the SB value of each 'grids' in the profile with the sampled radius.
    '''
    if if_mask == False:
        r_flux, r_grids, regions=flux_profile(image, center, radius=radius, grids=grids, ifplot=False, fits_plot=False)
        region_area = np.zeros([len(r_flux)])
        for i in range(len(r_flux)):
            circle=regions[i].to_mask(mode='exact')
            edge_mask = circle.cutout(np.ones(image.shape))
            region_area[i]=(circle.data * edge_mask).sum()
    elif if_mask == True:
        mask = np.ones(image.shape)
        for i in range(mask_NO):
            mask *= cr_mask(image=image, filename=mask_reg[i])
        r_flux, r_grids, regions=flux_profile(image*mask, center, radius=radius, grids=grids, ifplot=False, fits_plot=False)
        region_area = np.zeros([len(r_flux)])
        for i in range(len(r_flux)):
            circle=regions[i].to_mask(mode='exact')
            circle_mask =  circle.cutout(mask)
            if i ==len(r_flux)-1:
                plt.imshow(np.log10(circle_mask),origin='lower')
                plt.show()
            region_area[i]=(circle.data * circle_mask).sum()
    r_SB= r_flux/region_area
    if fits_plot == True:
        ax=plt.subplot(1,1,1)
        if if_mask == True:
            cax=ax.imshow(np.log10(image*mask),origin='lower')
        elif if_mask == False:
            cax=ax.imshow(np.log10(image),origin='lower')
        #ax.add_patch(mask.bbox.as_patch(facecolor='none', edgecolor='white'))
        for i in range(grids):
            ax.add_patch(regions[i].as_patch(facecolor='none', edgecolor='orange'))
        plt.colorbar(cax)
        plt.show()
    if ifplot == True:
        minorLocator = AutoMinorLocator()
        fig, ax = plt.subplots()
        plt.plot(r_grids, r_SB, 'x-')
        ax.xaxis.set_minor_locator(minorLocator)
        plt.tick_params(which='both', width=2)
        plt.tick_params(which='major', length=7)
        plt.tick_params(which='minor', length=4, color='r')
        plt.grid()
        ax.set_ylabel("Total Flux")
        ax.set_xlabel("Pixels")
        plt.grid(which="minor")
        plt.show()
    return r_SB, r_grids

def PSF_SB_compare(psfs, masks=['default.reg'], radius=15, grids=20):
    psfs_NO = len(psfs)
    center = (psfs[0].shape[0]/2, psfs[0].shape[1]/2 )
    minorLocator = AutoMinorLocator()
    fig, ax = plt.subplots()
    for i in range(psfs_NO):
        if i ==0:
            r_SB, r_grids = SB_profile(psfs[i], center, radius=radius, grids=grids, fits_plot=True)
        else:
            r_SB, r_grids = SB_profile(psfs[i], center, radius=radius, grids=grids)
        r_SB /= r_SB[0]      #normalize the curves from the central part.
        plt.plot(r_grids, r_SB, 'x-', label="PSF{0}".format(i))
        plt.legend()
    ax.xaxis.set_minor_locator(minorLocator)
    plt.tick_params(which='both', width=2)
    plt.tick_params(which='major', length=7)
    plt.tick_params(which='minor', length=4, color='r')
    plt.grid()
    ax.set_ylabel("Total Flux")
    ax.set_xlabel("Pixels")
    plt.grid(which="minor")
    plt.show()

def SB_compare(QSO, psfs, masks=['default.reg'], radius=15, grids=20):
    minorLocator = AutoMinorLocator()
    fig, ax = plt.subplots()
    center_QSO = (QSO.shape[0]/2, QSO.shape[1]/2 )
    r_SB, r_grids = SB_profile(QSO, center=center_QSO, radius=radius, grids=grids, fits_plot=True)
    r_SB /= r_SB[0]
    plt.plot(r_grids, r_SB, 'x-', label="QSO", linewidth=3)
    plt.legend()
    psfs_NO = len(psfs)
    center = (psfs[0].shape[0]/2, psfs[0].shape[1]/2)
    for i in range(psfs_NO):
        if i ==0:
            r_SB, r_grids = SB_profile(psfs[i], center, radius=radius, grids=grids)
        else:
            r_SB, r_grids = SB_profile(psfs[i], center, radius=radius, grids=grids)
        r_SB /= r_SB[0]      #normalize the curves from the central part.
        plt.plot(r_grids, r_SB, 'x-', label="PSF{0}".format(i))
        plt.legend()
    ax.xaxis.set_minor_locator(minorLocator)
    plt.tick_params(which='both', width=2)
    plt.tick_params(which='major', length=7)
    plt.tick_params(which='minor', length=4, color='r')
    plt.grid()
    ax.set_ylabel("Total Flux")
    ax.set_xlabel("Pixels")
    plt.grid(which="minor")
    plt.show()

def string_find_between( s, first, last ):
    try:
        start = s.index( first ) + len( first )
        end = s.index( last, start )
        return s[start:end]
    except ValueError:
        return ""

def cr_mask(image, filename='test_circle.reg'):
    '''
    The creat a mask with a .reg file. The pixels in the region is 0, otherwise 1.
    
    Parameter
    --------
        filename: filename of the .reg
        image:
        
    Return
    --------
        A image.shape array. Pixels in the region is 0, otherwise 1.
    '''
    ##### Note the numpy starts from 0, especially in the center,
    ####!!!Need to check the center, shape of the boxtype, the size?
    with open(filename, 'r') as input_file:
        reg_string=input_file.read().replace('\n', '')
    if "physicalcircle" in reg_string:
        abc=string_find_between(reg_string, "(", ")")
        reg_info=np.fromstring(abc, dtype=float, sep=',')
        center, radius = reg_info[:2]-1, reg_info[2]
        region = pix_region(center, radius)
        box = 1-region.to_mask(mode='center').data
    elif "physicalbox" in reg_string:
        abc=string_find_between(reg_string, "(", ")")
        reg_info=np.fromstring(abc, dtype=float, sep=',')
        center = reg_info[:2] - 1
        x_r, y_r = reg_info[2:4]  # x_r is the length of the x, y_r is the length of the y
        box = np.zeros([np.int(x_r)+1, np.int(y_r)+1]).T
    else:
        raise ValueError("The input reg is un-defined yet")
    frame_size = image.shape
    box_size = box.shape
    x_edge = np.int(center[1]-box_size[0]/2) #The position of the center is x-y switched.
    y_edge = np.int(center[0]-box_size[1]/2)
    mask = np.ones(frame_size)
    mask_box_part = mask[x_edge:x_edge+box_size[0],y_edge: y_edge + box_size[1]]
    mask_box_part *= box
    return mask

